use std::fmt::Display;

use hyperast::tree_gen::utils_ts::{TsEnableTS, TsType};
use hyperast::types::{
    AAAA, AnyType, HyperType, LangRef, NodeId, TypeStore, TypeTrait, TypeU16, TypedNodeId,
};

#[cfg(feature = "legion")]
mod legion_impls {

    use super::*;
    impl TsEnableTS for TStore {
        fn obtain_type<'a, N: hyperast::tree_gen::parser::NodeWithU16TypeId>(
            n: &N,
        ) -> <Self as hyperast::types::ETypeStore>::Ty2 {
            let k = n.kind_id();
            Type::from_u16(k)
        }

        fn try_obtain_type<N: hyperast::tree_gen::parser::NodeWithU16TypeId>(
            n: &N,
        ) -> Option<Self::Ty2> {
            let k = n.kind_id();
            static LEN: u16 = S_T_L.len() as u16;
            if LEN <= k && k < TStore::LOWEST_RESERVED {
                return None;
            }
            Some(Type::from_u16(k))
        }
    }

    impl TsType for Type {
        fn spaces() -> Self {
            Self::Spaces
        }

        fn is_repeat(&self) -> bool {
            self.is_repeat()
        }
    }

    impl<'a> hyperast::types::ETypeStore for TStore {
        type Ty2 = Type;

        fn intern(ty: Self::Ty2) -> Self::Ty {
            TType::new(ty)
        }
    }

    impl TypeStore for TStore {
        type Ty = TypeU16<Ts>;
    }
    impl TsEnabledTypeStore for TStore {
        fn resolve(t: Self::Ty) -> Type {
            t.e()
        }
    }
}

pub trait TsEnabledTypeStore: hyperast::types::ETypeStore<Ty2 = Type> + Clone + TsEnableTS {
    fn resolve(t: Self::Ty) -> Type;
}

impl Type {
    pub fn resolve(t: u16) -> Self {
        assert!(t < COUNT);
        unsafe { std::mem::transmute(t) }
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]
pub struct TIdN<IdN>(IdN);

impl<IdN: Clone + Eq + AAAA + std::hash::Hash> NodeId for TIdN<IdN> {
    type IdN = IdN;

    fn as_id(&self) -> &Self::IdN {
        &self.0
    }

    unsafe fn from_id(id: Self::IdN) -> Self {
        Self(id)
    }

    unsafe fn from_ref_id(_id: &Self::IdN) -> &Self {
        todo!()
    }
}

#[cfg(feature = "impl")]
fn id_for_node_kind(kind: &str, named: bool) -> u16 {
    crate::language().id_for_node_kind(kind, named)
}
#[cfg(not(feature = "impl"))]
fn id_for_node_kind(kind: &str, named: bool) -> u16 {
    unimplemented!("need treesitter grammar")
}

impl<IdN: Clone + Eq + AAAA> TypedNodeId for TIdN<IdN> {
    type Ty = Type;
    type TyErazed = TType;
    fn unerase(ty: Self::TyErazed) -> Self::Ty {
        ty.e()
    }
}

#[derive(Clone, Copy)]
pub(crate) struct TStore;

impl Default for TStore {
    fn default() -> Self {
        Self
    }
}

type TypeInternalSize = u16;

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct T(TypeInternalSize);

#[derive(Debug)]
pub struct Lang;
pub type Ts = Lang;

impl LangRef<AnyType> for Ts {
    fn make(&self, _t: u16) -> &'static AnyType {
        panic!()
        // &From::<&'static dyn HyperType>::from(&S_T_L[t as usize])
    }
    fn to_u16(&self, t: AnyType) -> u16 {
        // t as u16
        let t = t.as_any().downcast_ref::<Type>().unwrap();
        *t as u16
    }

    fn name(&self) -> &'static str {
        std::any::type_name::<Ts>()
    }

    fn ts_symbol(&self, t: AnyType) -> u16 {
        id_for_node_kind(t.as_static_str(), t.is_named())
    }
}

impl LangRef<Type> for Ts {
    fn make(&self, t: u16) -> &'static Type {
        if t == TStore::ERROR {
            &Type::ERROR
        } else if t == TStore::_ERROR {
            &Type::_ERROR
        } else if t == TStore::SPACES {
            &Type::Spaces
        } else if t == TStore::DIRECTORY {
            &Type::Directory
        } else {
            &S_T_L[t as usize]
        }
    }
    fn to_u16(&self, t: Type) -> u16 {
        t as u16
    }

    fn name(&self) -> &'static str {
        std::any::type_name::<Ts>()
    }

    fn ts_symbol(&self, t: Type) -> u16 {
        id_for_node_kind(t.as_static_str(), t.is_named())
    }
}

impl LangRef<TType> for Lang {
    fn make(&self, t: u16) -> &'static TType {
        // TODO could make one safe, but not priority
        unsafe { std::mem::transmute(&S_T_L[t as usize]) }
    }
    fn to_u16(&self, t: TType) -> u16 {
        t.e() as u16
    }

    fn name(&self) -> &'static str {
        std::any::type_name::<Lang>()
    }

    fn ts_symbol(&self, t: TType) -> u16 {
        id_for_node_kind(t.as_static_str(), t.is_named())
    }
}

impl hyperast::types::Lang<Type> for Ts {
    fn make(t: u16) -> &'static Type {
        Lang.make(t)
    }
    fn to_u16(t: Type) -> u16 {
        Lang.to_u16(t)
    }
}

impl HyperType for Type {
    fn generic_eq(&self, other: &dyn HyperType) -> bool
    where
        Self: 'static + PartialEq + Sized,
    {
        // Do a type-safe casting. If the types are different,
        // return false, otherwise test the values for equality.
        other
            .as_any()
            .downcast_ref::<Self>()
            .map_or(false, |a| self == a)
    }

    fn is_directory(&self) -> bool {
        self == &Type::Directory
    }

    fn is_file(&self) -> bool {
        todo!()
    }

    fn is_spaces(&self) -> bool {
        self == &Type::Spaces
        // setting TS0 as space is causing an issue with global_pos_with_spaces
        // and TS0 is end list of tokens, so maybe other issues.
        // Actual fix is to skip TS0 in skipable_pre in the generator,
        // thus TSO should not appear anymore in generated ast.
        // || self == &Type::TS0
    }

    fn is_syntax(&self) -> bool {
        todo!()
    }

    fn as_shared(&self) -> hyperast::types::Shared {
        use hyperast::types::Shared;

        match self {
            Type::ClassDeclaration => Shared::TypeDeclaration,
            Type::EnumDeclaration => Shared::TypeDeclaration,
            Type::TypeAliasDeclaration => Shared::TypeDeclaration,
            Type::InterfaceDeclaration => Shared::TypeDeclaration,
            Type::AbstractClassDeclaration => Shared::TypeDeclaration,
            Type::FunctionDeclaration => Shared::TypeDeclaration,
            Type::Comment => Shared::Comment,
            Type::Identifier => Shared::Identifier,
            _ => Shared::Other,
        }
    }

    fn as_abstract(&self) -> hyperast::types::Abstracts {
        use hyperast::types::Abstract;
        Abstract::Expression.when(self.is_expression())
            | Abstract::Statement.when(self.is_statement())
            | Abstract::Executable.when(self.is_executable_member())
            | Abstract::Declaration.when(self.is_type_declaration())
            | Abstract::Literal.when(self.is_literal())
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }

    fn as_static(&self) -> &'static dyn HyperType {
        let t = <Ts as hyperast::types::Lang<Type>>::to_u16(*self);
        let t = <Ts as hyperast::types::Lang<Type>>::make(t);
        t
    }

    fn as_static_str(&self) -> &'static str {
        self.to_str()
    }

    fn is_hidden(&self) -> bool {
        todo!()
    }

    fn is_supertype(&self) -> bool {
        todo!()
    }

    fn is_named(&self) -> bool {
        todo!()
    }

    fn get_lang(&self) -> hyperast::types::LangWrapper<Self>
    where
        Self: Sized,
    {
        From::<&'static (dyn LangRef<Self>)>::from(&Lang)
    }
    fn lang_ref(&self) -> hyperast::types::LangWrapper<AnyType> {
        todo!()
    }
}
impl TypeTrait for Type {
    type Lang = Ts;

    fn is_fork(&self) -> bool {
        todo!()
    }

    fn is_literal(&self) -> bool {
        todo!()
    }

    fn is_primitive(&self) -> bool {
        todo!()
    }

    fn is_type_declaration(&self) -> bool {
        todo!()
    }

    fn is_identifier(&self) -> bool {
        todo!()
    }

    fn is_instance_ref(&self) -> bool {
        todo!()
    }

    fn is_type_body(&self) -> bool {
        todo!()
    }

    fn is_value_member(&self) -> bool {
        todo!()
    }

    fn is_executable_member(&self) -> bool {
        todo!()
    }

    fn is_statement(&self) -> bool {
        todo!()
    }

    fn is_declarative_statement(&self) -> bool {
        todo!()
    }

    fn is_structural_statement(&self) -> bool {
        todo!()
    }

    fn is_block_related(&self) -> bool {
        todo!()
    }

    fn is_simple_statement(&self) -> bool {
        todo!()
    }

    fn is_local_declare(&self) -> bool {
        todo!()
    }

    fn is_parameter(&self) -> bool {
        todo!()
    }

    fn is_parameter_list(&self) -> bool {
        todo!()
    }

    fn is_argument_list(&self) -> bool {
        todo!()
    }

    fn is_expression(&self) -> bool {
        todo!()
    }

    fn is_comment(&self) -> bool {
        todo!()
    }
}

// 356 + directory  + spaces
const COUNT: u16 = 358;

impl Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.to_str())
    }
}

type TType = hyperast::types::TypeU16<Lang>;

impl hyperast::types::LLang<TType> for Ts {
    type I = u16;

    type E = Type;

    const TE: &[Self::E] = S_T_L;

    fn as_lang_wrapper() -> hyperast::types::LangWrapper<TType> {
        From::<&'static (dyn LangRef<_>)>::from(&Lang)
    }
}

impl From<u16> for Type {
    fn from(value: u16) -> Self {
        debug_assert_eq!(Self::from_u16(value), S_T_L[value as usize]);
        S_T_L[value as usize]
    }
}
impl Into<TypeU16<Ts>> for Type {
    fn into(self) -> TypeU16<Ts> {
        TypeU16::new(self)
    }
}

impl Into<u16> for Type {
    fn into(self) -> u16 {
        self as u8 as u16
    }
}

#[repr(u16)]
#[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]
pub enum Type {
    End,
    Identifier,
    HashBangLine,
    Export,
    Star,
    Default,
    Type,
    Eq,
    As,
    Namespace,
    LBrace,
    Comma,
    RBrace,
    Typeof,
    Import,
    From,
    With,
    Assert,
    Var,
    Let,
    Const,
    Bang,
    Else,
    If,
    Switch,
    For,
    LParen,
    SemiColon,
    RParen,
    Await,
    In,
    Of,
    While,
    Do,
    Try,
    Break,
    Continue,
    Debugger,
    Return,
    Throw,
    Colon,
    Case,
    Catch,
    Finally,
    Yield,
    LBracket,
    RBracket,
    Dot,
    Class,
    Async,
    Function,
    BigArrow,
    QMarkDot,
    New,
    Using,
    PlusEq,
    DashEq,
    StarEq,
    SlashEq,
    PercentEq,
    CaretEq,
    AmpEq,
    PipeEq,
    GtGtEq,
    GtGtGtEq,
    LtLtEq,
    StarStarEq,
    AmpAmpEq,
    PipePipeEq,
    QMarkQMarkEq,
    DotDotDot,
    AmpAmp,
    PipePipe,
    GtGt,
    GtGtGt,
    LtLt,
    Amp,
    Caret,
    Pipe,
    Plus,
    Dash,
    Slash,
    Percent,
    StarStar,
    LT,
    LTEq,
    EqEq,
    EqEqEq,
    BangEq,
    BangEqEq,
    GTEq,
    GT,
    QMarkQMark,
    Instanceof,
    Tilde,
    Void,
    Delete,
    PlusPlus,
    DashDash,
    DQuote,
    SQuote,
    StringFragment,
    EscapeSequence,
    Comment,
    BQuote,
    DollarLBrace,
    RegexPattern,
    RegexFlags,
    Number,
    PrivatePropertyIdentifier,
    Target,
    Meta,
    This,
    Super,
    True,
    False,
    Null,
    Undefined,
    At,
    Static,
    Readonly,
    Get,
    Set,
    QMark,
    Declare,
    Public,
    Private,
    Protected,
    Override,
    Module,
    Any,
    Boolean,
    String,
    Symbol,
    Object,
    Abstract,
    Accessor,
    Satisfies,
    Require,
    Extends,
    Implements,
    Global,
    Interface,
    Enum,
    MinusQMarkColon,
    PlusQMarkColon,
    QMarkColon,
    Asserts,
    Infer,
    Is,
    Keyof,
    TS0,
    Unknown,
    Never,
    LBracePipe,
    PipeRBrace,
    _AutomaticSemicolon,
    HtmlComment,
    JsxText,
    _FunctionSignatureAutomaticSemicolon,
    __ErrorRecovery,
    Program,
    ExportStatement,
    NamespaceExport,
    ExportClause,
    ExportSpecifier,
    _ModuleExportName,
    Declaration,
    ImportStatement,
    ImportClause,
    _FromClause,
    NamespaceImport,
    NamedImports,
    ImportSpecifier,
    ImportAttribute,
    Statement,
    ExpressionStatement,
    VariableDeclaration,
    LexicalDeclaration,
    VariableDeclarator,
    StatementBlock,
    ElseClause,
    IfStatement,
    SwitchStatement,
    ForStatement,
    ForInStatement,
    _ForHeader,
    WhileStatement,
    DoStatement,
    TryStatement,
    WithStatement,
    BreakStatement,
    ContinueStatement,
    DebuggerStatement,
    ReturnStatement,
    ThrowStatement,
    EmptyStatement,
    LabeledStatement,
    SwitchBody,
    SwitchCase,
    SwitchDefault,
    CatchClause,
    FinallyClause,
    ParenthesizedExpression,
    Expression,
    PrimaryExpression,
    YieldExpression,
    ObjectPattern,
    AssignmentPattern,
    ObjectAssignmentPattern,
    Array,
    ArrayPattern,
    NestedIdentifier,
    ClassDeclaration,
    ClassHeritage,
    FunctionExpression,
    FunctionDeclaration,
    GeneratorFunction,
    GeneratorFunctionDeclaration,
    ArrowFunction,
    _CallSignature,
    _FormalParameter,
    OptionalChain,
    CallExpression,
    NewExpression,
    AwaitExpression,
    MemberExpression,
    SubscriptExpression,
    AssignmentExpression,
    _AugmentedAssignmentLhs,
    AugmentedAssignmentExpression,
    _Initializer,
    _DestructuringPattern,
    SpreadElement,
    TernaryExpression,
    BinaryExpression,
    UnaryExpression,
    UpdateExpression,
    SequenceExpression,
    TemplateString,
    TemplateSubstitution,
    Regex,
    MetaProperty,
    Arguments,
    Decorator,
    ClassBody,
    FormalParameters,
    ClassStaticBlock,
    Pattern,
    RestPattern,
    MethodDefinition,
    Pair,
    PairPattern,
    _PropertyName,
    ComputedPropertyName,
    PublicFieldDefinition,
    _ImportIdentifier,
    NonNullExpression,
    MethodSignature,
    AbstractMethodSignature,
    FunctionSignature,
    TypeAssertion,
    AsExpression,
    SatisfiesExpression,
    InstantiationExpression,
    ImportRequireClause,
    ExtendsClause,
    _ExtendsClauseSingle,
    ImplementsClause,
    AmbientDeclaration,
    AbstractClassDeclaration,
    InternalModule,
    _Module,
    ImportAlias,
    NestedTypeIdentifier,
    InterfaceDeclaration,
    ExtendsTypeClause,
    EnumDeclaration,
    EnumBody,
    EnumAssignment,
    TypeAliasDeclaration,
    AccessibilityModifier,
    OverrideModifier,
    RequiredParameter,
    OptionalParameter,
    _ParameterName,
    OmittingTypeAnnotation,
    AddingTypeAnnotation,
    OptingTypeAnnotation,
    TypeAnnotation,
    AssertsAnnotation,
    OptionalType,
    RestType,
    _TupleTypeMember,
    ConstructorType,
    PrimaryType,
    TemplateType,
    TemplateLiteralType,
    InferType,
    ConditionalType,
    GenericType,
    TypePredicate,
    TypePredicateAnnotation,
    TypeQuery,
    IndexTypeQuery,
    LookupType,
    MappedTypeClause,
    LiteralType,
    ExistentialType,
    FlowMaybeType,
    ParenthesizedType,
    PredefinedType,
    TypeArguments,
    ObjectType,
    CallSignature,
    PropertySignature,
    TypeParameters,
    TypeParameter,
    DefaultType,
    Constraint,
    ConstructSignature,
    IndexSignature,
    ArrayType,
    TupleType,
    ReadonlyType,
    UnionType,
    IntersectionType,
    FunctionType,
    ProgramRepeat1,
    ExportStatementRepeat1,
    ExportClauseRepeat1,
    NamedImportsRepeat1,
    VariableDeclarationRepeat1,
    SwitchBodyRepeat1,
    ObjectRepeat1,
    ObjectPatternRepeat1,
    ArrayRepeat1,
    ArrayPatternRepeat1,
    SequenceExpressionRepeat1,
    StringRepeat1,
    StringRepeat2,
    TemplateStringRepeat1,
    ClassBodyRepeat1,
    FormalParametersRepeat1,
    ExtendsClauseRepeat1,
    ImplementsClauseRepeat1,
    ExtendsTypeClauseRepeat1,
    EnumBodyRepeat1,
    TemplateLiteralTypeRepeat1,
    ObjectTypeRepeat1,
    TypeParametersRepeat1,
    TupleTypeRepeat1,
    InterfaceBody,
    PropertyIdentifier,
    ShorthandPropertyIdentifier,
    ShorthandPropertyIdentifierPattern,
    StatementIdentifier,
    ThisType,
    TypeIdentifier,
    Directory = TStore::DIRECTORY,
    Spaces = TStore::SPACES,
    _ERROR = TStore::_ERROR,
    ERROR = TStore::ERROR,
}
impl Type {
    pub fn from_u16(t: u16) -> Type {
        match t {
            0u16 => Type::End,
            1u16 => Type::Identifier,
            2u16 => Type::HashBangLine,
            3u16 => Type::Export,
            4u16 => Type::Star,
            5u16 => Type::Default,
            6u16 => Type::Type,
            7u16 => Type::Eq,
            8u16 => Type::As,
            9u16 => Type::Namespace,
            10u16 => Type::LBrace,
            11u16 => Type::Comma,
            12u16 => Type::RBrace,
            13u16 => Type::Typeof,
            14u16 => Type::Import,
            15u16 => Type::From,
            16u16 => Type::With,
            17u16 => Type::Assert,
            18u16 => Type::Var,
            19u16 => Type::Let,
            20u16 => Type::Const,
            21u16 => Type::Bang,
            22u16 => Type::Else,
            23u16 => Type::If,
            24u16 => Type::Switch,
            25u16 => Type::For,
            26u16 => Type::LParen,
            27u16 => Type::SemiColon,
            28u16 => Type::RParen,
            29u16 => Type::Await,
            30u16 => Type::In,
            31u16 => Type::Of,
            32u16 => Type::While,
            33u16 => Type::Do,
            34u16 => Type::Try,
            35u16 => Type::Break,
            36u16 => Type::Continue,
            37u16 => Type::Debugger,
            38u16 => Type::Return,
            39u16 => Type::Throw,
            40u16 => Type::Colon,
            41u16 => Type::Case,
            42u16 => Type::Catch,
            43u16 => Type::Finally,
            44u16 => Type::Yield,
            45u16 => Type::LBracket,
            46u16 => Type::RBracket,
            47u16 => Type::Dot,
            48u16 => Type::Class,
            49u16 => Type::Async,
            50u16 => Type::Function,
            51u16 => Type::BigArrow,
            52u16 => Type::QMarkDot,
            53u16 => Type::New,
            54u16 => Type::Using,
            55u16 => Type::PlusEq,
            56u16 => Type::DashEq,
            57u16 => Type::StarEq,
            58u16 => Type::SlashEq,
            59u16 => Type::PercentEq,
            60u16 => Type::CaretEq,
            61u16 => Type::AmpEq,
            62u16 => Type::PipeEq,
            63u16 => Type::GtGtEq,
            64u16 => Type::GtGtGtEq,
            65u16 => Type::LtLtEq,
            66u16 => Type::StarStarEq,
            67u16 => Type::AmpAmpEq,
            68u16 => Type::PipePipeEq,
            69u16 => Type::QMarkQMarkEq,
            70u16 => Type::DotDotDot,
            71u16 => Type::AmpAmp,
            72u16 => Type::PipePipe,
            73u16 => Type::GtGt,
            74u16 => Type::GtGtGt,
            75u16 => Type::LtLt,
            76u16 => Type::Amp,
            77u16 => Type::Caret,
            78u16 => Type::Pipe,
            79u16 => Type::Plus,
            80u16 => Type::Dash,
            81u16 => Type::Slash,
            82u16 => Type::Percent,
            83u16 => Type::StarStar,
            84u16 => Type::LT,
            85u16 => Type::LTEq,
            86u16 => Type::EqEq,
            87u16 => Type::EqEqEq,
            88u16 => Type::BangEq,
            89u16 => Type::BangEqEq,
            90u16 => Type::GTEq,
            91u16 => Type::GT,
            92u16 => Type::QMarkQMark,
            93u16 => Type::Instanceof,
            94u16 => Type::Tilde,
            95u16 => Type::Void,
            96u16 => Type::Delete,
            97u16 => Type::PlusPlus,
            98u16 => Type::DashDash,
            99u16 => Type::DQuote,
            100u16 => Type::SQuote,
            101u16 => Type::StringFragment,
            102u16 => Type::StringFragment,
            103u16 => Type::EscapeSequence,
            104u16 => Type::Comment,
            105u16 => Type::BQuote,
            106u16 => Type::DollarLBrace,
            107u16 => Type::Slash,
            108u16 => Type::RegexPattern,
            109u16 => Type::RegexFlags,
            110u16 => Type::Number,
            111u16 => Type::PrivatePropertyIdentifier,
            112u16 => Type::Target,
            113u16 => Type::Meta,
            114u16 => Type::This,
            115u16 => Type::Super,
            116u16 => Type::True,
            117u16 => Type::False,
            118u16 => Type::Null,
            119u16 => Type::Undefined,
            120u16 => Type::At,
            121u16 => Type::Static,
            122u16 => Type::Readonly,
            123u16 => Type::Get,
            124u16 => Type::Set,
            125u16 => Type::QMark,
            126u16 => Type::Declare,
            127u16 => Type::Public,
            128u16 => Type::Private,
            129u16 => Type::Protected,
            130u16 => Type::Override,
            131u16 => Type::Module,
            132u16 => Type::Any,
            133u16 => Type::Number,
            134u16 => Type::Boolean,
            135u16 => Type::String,
            136u16 => Type::Symbol,
            137u16 => Type::Object,
            138u16 => Type::Abstract,
            139u16 => Type::Accessor,
            140u16 => Type::Satisfies,
            141u16 => Type::Require,
            142u16 => Type::Extends,
            143u16 => Type::Implements,
            144u16 => Type::Global,
            145u16 => Type::Interface,
            146u16 => Type::Enum,
            147u16 => Type::MinusQMarkColon,
            148u16 => Type::PlusQMarkColon,
            149u16 => Type::QMarkColon,
            150u16 => Type::Asserts,
            151u16 => Type::Infer,
            152u16 => Type::Is,
            153u16 => Type::Keyof,
            154u16 => Type::TS0,
            155u16 => Type::Unknown,
            156u16 => Type::Never,
            157u16 => Type::LBracePipe,
            158u16 => Type::PipeRBrace,
            159u16 => Type::_AutomaticSemicolon,
            160u16 => Type::StringFragment,
            161u16 => Type::QMark,
            162u16 => Type::HtmlComment,
            163u16 => Type::JsxText,
            164u16 => Type::_FunctionSignatureAutomaticSemicolon,
            165u16 => Type::__ErrorRecovery,
            166u16 => Type::Program,
            167u16 => Type::ExportStatement,
            168u16 => Type::NamespaceExport,
            169u16 => Type::ExportClause,
            170u16 => Type::ExportSpecifier,
            171u16 => Type::_ModuleExportName,
            172u16 => Type::Declaration,
            173u16 => Type::Import,
            174u16 => Type::ImportStatement,
            175u16 => Type::ImportClause,
            176u16 => Type::_FromClause,
            177u16 => Type::NamespaceImport,
            178u16 => Type::NamedImports,
            179u16 => Type::ImportSpecifier,
            180u16 => Type::ImportAttribute,
            181u16 => Type::Statement,
            182u16 => Type::ExpressionStatement,
            183u16 => Type::VariableDeclaration,
            184u16 => Type::LexicalDeclaration,
            185u16 => Type::VariableDeclarator,
            186u16 => Type::StatementBlock,
            187u16 => Type::ElseClause,
            188u16 => Type::IfStatement,
            189u16 => Type::SwitchStatement,
            190u16 => Type::ForStatement,
            191u16 => Type::ForInStatement,
            192u16 => Type::_ForHeader,
            193u16 => Type::WhileStatement,
            194u16 => Type::DoStatement,
            195u16 => Type::TryStatement,
            196u16 => Type::WithStatement,
            197u16 => Type::BreakStatement,
            198u16 => Type::ContinueStatement,
            199u16 => Type::DebuggerStatement,
            200u16 => Type::ReturnStatement,
            201u16 => Type::ThrowStatement,
            202u16 => Type::EmptyStatement,
            203u16 => Type::LabeledStatement,
            204u16 => Type::SwitchBody,
            205u16 => Type::SwitchCase,
            206u16 => Type::SwitchDefault,
            207u16 => Type::CatchClause,
            208u16 => Type::FinallyClause,
            209u16 => Type::ParenthesizedExpression,
            210u16 => Type::Expression,
            211u16 => Type::PrimaryExpression,
            212u16 => Type::YieldExpression,
            213u16 => Type::Object,
            214u16 => Type::ObjectPattern,
            215u16 => Type::AssignmentPattern,
            216u16 => Type::ObjectAssignmentPattern,
            217u16 => Type::Array,
            218u16 => Type::ArrayPattern,
            219u16 => Type::NestedIdentifier,
            220u16 => Type::Class,
            221u16 => Type::ClassDeclaration,
            222u16 => Type::ClassHeritage,
            223u16 => Type::FunctionExpression,
            224u16 => Type::FunctionDeclaration,
            225u16 => Type::GeneratorFunction,
            226u16 => Type::GeneratorFunctionDeclaration,
            227u16 => Type::ArrowFunction,
            228u16 => Type::_CallSignature,
            229u16 => Type::_FormalParameter,
            230u16 => Type::OptionalChain,
            231u16 => Type::CallExpression,
            232u16 => Type::NewExpression,
            233u16 => Type::AwaitExpression,
            234u16 => Type::MemberExpression,
            235u16 => Type::SubscriptExpression,
            236u16 => Type::AssignmentExpression,
            237u16 => Type::_AugmentedAssignmentLhs,
            238u16 => Type::AugmentedAssignmentExpression,
            239u16 => Type::_Initializer,
            240u16 => Type::_DestructuringPattern,
            241u16 => Type::SpreadElement,
            242u16 => Type::TernaryExpression,
            243u16 => Type::BinaryExpression,
            244u16 => Type::UnaryExpression,
            245u16 => Type::UpdateExpression,
            246u16 => Type::SequenceExpression,
            247u16 => Type::String,
            248u16 => Type::TemplateString,
            249u16 => Type::TemplateSubstitution,
            250u16 => Type::Regex,
            251u16 => Type::MetaProperty,
            252u16 => Type::Arguments,
            253u16 => Type::Decorator,
            254u16 => Type::MemberExpression,
            255u16 => Type::CallExpression,
            256u16 => Type::ClassBody,
            257u16 => Type::FormalParameters,
            258u16 => Type::ClassStaticBlock,
            259u16 => Type::Pattern,
            260u16 => Type::RestPattern,
            261u16 => Type::MethodDefinition,
            262u16 => Type::Pair,
            263u16 => Type::PairPattern,
            264u16 => Type::_PropertyName,
            265u16 => Type::ComputedPropertyName,
            266u16 => Type::PublicFieldDefinition,
            267u16 => Type::_ImportIdentifier,
            268u16 => Type::NonNullExpression,
            269u16 => Type::MethodSignature,
            270u16 => Type::AbstractMethodSignature,
            271u16 => Type::FunctionSignature,
            272u16 => Type::ParenthesizedExpression,
            273u16 => Type::TypeAssertion,
            274u16 => Type::AsExpression,
            275u16 => Type::SatisfiesExpression,
            276u16 => Type::InstantiationExpression,
            277u16 => Type::ImportRequireClause,
            278u16 => Type::ExtendsClause,
            279u16 => Type::_ExtendsClauseSingle,
            280u16 => Type::ImplementsClause,
            281u16 => Type::AmbientDeclaration,
            282u16 => Type::AbstractClassDeclaration,
            283u16 => Type::Module,
            284u16 => Type::InternalModule,
            285u16 => Type::_Module,
            286u16 => Type::ImportAlias,
            287u16 => Type::NestedTypeIdentifier,
            288u16 => Type::InterfaceDeclaration,
            289u16 => Type::ExtendsTypeClause,
            290u16 => Type::EnumDeclaration,
            291u16 => Type::EnumBody,
            292u16 => Type::EnumAssignment,
            293u16 => Type::TypeAliasDeclaration,
            294u16 => Type::AccessibilityModifier,
            295u16 => Type::OverrideModifier,
            296u16 => Type::RequiredParameter,
            297u16 => Type::OptionalParameter,
            298u16 => Type::_ParameterName,
            299u16 => Type::OmittingTypeAnnotation,
            300u16 => Type::AddingTypeAnnotation,
            301u16 => Type::OptingTypeAnnotation,
            302u16 => Type::TypeAnnotation,
            303u16 => Type::MemberExpression,
            304u16 => Type::CallExpression,
            305u16 => Type::Asserts,
            306u16 => Type::AssertsAnnotation,
            307u16 => Type::Type,
            308u16 => Type::RequiredParameter,
            309u16 => Type::OptionalParameter,
            310u16 => Type::OptionalType,
            311u16 => Type::RestType,
            312u16 => Type::_TupleTypeMember,
            313u16 => Type::ConstructorType,
            314u16 => Type::PrimaryType,
            315u16 => Type::TemplateType,
            316u16 => Type::TemplateLiteralType,
            317u16 => Type::InferType,
            318u16 => Type::ConditionalType,
            319u16 => Type::GenericType,
            320u16 => Type::TypePredicate,
            321u16 => Type::TypePredicateAnnotation,
            322u16 => Type::MemberExpression,
            323u16 => Type::SubscriptExpression,
            324u16 => Type::CallExpression,
            325u16 => Type::InstantiationExpression,
            326u16 => Type::TypeQuery,
            327u16 => Type::IndexTypeQuery,
            328u16 => Type::LookupType,
            329u16 => Type::MappedTypeClause,
            330u16 => Type::LiteralType,
            331u16 => Type::UnaryExpression,
            332u16 => Type::ExistentialType,
            333u16 => Type::FlowMaybeType,
            334u16 => Type::ParenthesizedType,
            335u16 => Type::PredefinedType,
            336u16 => Type::TypeArguments,
            337u16 => Type::ObjectType,
            338u16 => Type::CallSignature,
            339u16 => Type::PropertySignature,
            340u16 => Type::TypeParameters,
            341u16 => Type::TypeParameter,
            342u16 => Type::DefaultType,
            343u16 => Type::Constraint,
            344u16 => Type::ConstructSignature,
            345u16 => Type::IndexSignature,
            346u16 => Type::ArrayType,
            347u16 => Type::TupleType,
            348u16 => Type::ReadonlyType,
            349u16 => Type::UnionType,
            350u16 => Type::IntersectionType,
            351u16 => Type::FunctionType,
            352u16 => Type::ProgramRepeat1,
            353u16 => Type::ExportStatementRepeat1,
            354u16 => Type::ExportClauseRepeat1,
            355u16 => Type::NamedImportsRepeat1,
            356u16 => Type::VariableDeclarationRepeat1,
            357u16 => Type::SwitchBodyRepeat1,
            358u16 => Type::ObjectRepeat1,
            359u16 => Type::ObjectPatternRepeat1,
            360u16 => Type::ArrayRepeat1,
            361u16 => Type::ArrayPatternRepeat1,
            362u16 => Type::SequenceExpressionRepeat1,
            363u16 => Type::StringRepeat1,
            364u16 => Type::StringRepeat2,
            365u16 => Type::TemplateStringRepeat1,
            366u16 => Type::ClassBodyRepeat1,
            367u16 => Type::FormalParametersRepeat1,
            368u16 => Type::ExtendsClauseRepeat1,
            369u16 => Type::ImplementsClauseRepeat1,
            370u16 => Type::ExtendsTypeClauseRepeat1,
            371u16 => Type::EnumBodyRepeat1,
            372u16 => Type::TemplateLiteralTypeRepeat1,
            373u16 => Type::ObjectTypeRepeat1,
            374u16 => Type::TypeParametersRepeat1,
            375u16 => Type::TupleTypeRepeat1,
            376u16 => Type::InterfaceBody,
            377u16 => Type::PropertyIdentifier,
            378u16 => Type::ShorthandPropertyIdentifier,
            379u16 => Type::ShorthandPropertyIdentifierPattern,
            380u16 => Type::StatementIdentifier,
            381u16 => Type::ThisType,
            382u16 => Type::TypeIdentifier,
            TStore::DIRECTORY => Type::Directory,
            TStore::SPACES => Type::Spaces,
            TStore::_ERROR => Type::_ERROR,
            TStore::ERROR => Type::ERROR,
            x => panic!("{}", x),
        }
    }
    pub fn from_str(t: &str) -> Option<Type> {
        Some(match t {
            "end" => Type::End,
            "identifier" => Type::Identifier,
            "hash_bang_line" => Type::HashBangLine,
            "export" => Type::Export,
            "*" => Type::Star,
            "default" => Type::Default,
            "type" => Type::Type,
            "=" => Type::Eq,
            "as" => Type::As,
            "namespace" => Type::Namespace,
            "{" => Type::LBrace,
            "," => Type::Comma,
            "}" => Type::RBrace,
            "typeof" => Type::Typeof,
            "import" => Type::Import,
            "from" => Type::From,
            "with" => Type::With,
            "assert" => Type::Assert,
            "var" => Type::Var,
            "let" => Type::Let,
            "const" => Type::Const,
            "!" => Type::Bang,
            "else" => Type::Else,
            "if" => Type::If,
            "switch" => Type::Switch,
            "for" => Type::For,
            "(" => Type::LParen,
            ";" => Type::SemiColon,
            ")" => Type::RParen,
            "await" => Type::Await,
            "in" => Type::In,
            "of" => Type::Of,
            "while" => Type::While,
            "do" => Type::Do,
            "try" => Type::Try,
            "break" => Type::Break,
            "continue" => Type::Continue,
            "debugger" => Type::Debugger,
            "return" => Type::Return,
            "throw" => Type::Throw,
            ":" => Type::Colon,
            "case" => Type::Case,
            "catch" => Type::Catch,
            "finally" => Type::Finally,
            "yield" => Type::Yield,
            "[" => Type::LBracket,
            "]" => Type::RBracket,
            "." => Type::Dot,
            "class" => Type::Class,
            "async" => Type::Async,
            "function" => Type::Function,
            "=>" => Type::BigArrow,
            "?." => Type::QMarkDot,
            "new" => Type::New,
            "using" => Type::Using,
            "+=" => Type::PlusEq,
            "-=" => Type::DashEq,
            "*=" => Type::StarEq,
            "/=" => Type::SlashEq,
            "%=" => Type::PercentEq,
            "^=" => Type::CaretEq,
            "&=" => Type::AmpEq,
            "|=" => Type::PipeEq,
            ">>=" => Type::GtGtEq,
            ">>>=" => Type::GtGtGtEq,
            "<<=" => Type::LtLtEq,
            "**=" => Type::StarStarEq,
            "&&=" => Type::AmpAmpEq,
            "||=" => Type::PipePipeEq,
            "??=" => Type::QMarkQMarkEq,
            "..." => Type::DotDotDot,
            "&&" => Type::AmpAmp,
            "||" => Type::PipePipe,
            ">>" => Type::GtGt,
            ">>>" => Type::GtGtGt,
            "<<" => Type::LtLt,
            "&" => Type::Amp,
            "^" => Type::Caret,
            "|" => Type::Pipe,
            "+" => Type::Plus,
            "-" => Type::Dash,
            "/" => Type::Slash,
            "%" => Type::Percent,
            "**" => Type::StarStar,
            "<" => Type::LT,
            "<=" => Type::LTEq,
            "==" => Type::EqEq,
            "===" => Type::EqEqEq,
            "!=" => Type::BangEq,
            "!==" => Type::BangEqEq,
            ">=" => Type::GTEq,
            ">" => Type::GT,
            "??" => Type::QMarkQMark,
            "instanceof" => Type::Instanceof,
            "~" => Type::Tilde,
            "void" => Type::Void,
            "delete" => Type::Delete,
            "++" => Type::PlusPlus,
            "--" => Type::DashDash,
            "\"" => Type::DQuote,
            "'" => Type::SQuote,
            "string_fragment" => Type::StringFragment,
            "escape_sequence" => Type::EscapeSequence,
            "comment" => Type::Comment,
            "`" => Type::BQuote,
            "${" => Type::DollarLBrace,
            "regex_pattern" => Type::RegexPattern,
            "regex_flags" => Type::RegexFlags,
            "number" => Type::Number,
            "private_property_identifier" => Type::PrivatePropertyIdentifier,
            "target" => Type::Target,
            "meta" => Type::Meta,
            "this" => Type::This,
            "super" => Type::Super,
            "true" => Type::True,
            "false" => Type::False,
            "null" => Type::Null,
            "undefined" => Type::Undefined,
            "@" => Type::At,
            "static" => Type::Static,
            "readonly" => Type::Readonly,
            "get" => Type::Get,
            "set" => Type::Set,
            "?" => Type::QMark,
            "declare" => Type::Declare,
            "public" => Type::Public,
            "private" => Type::Private,
            "protected" => Type::Protected,
            "override" => Type::Override,
            "module" => Type::Module,
            "any" => Type::Any,
            "boolean" => Type::Boolean,
            "string" => Type::String,
            "symbol" => Type::Symbol,
            "object" => Type::Object,
            "abstract" => Type::Abstract,
            "accessor" => Type::Accessor,
            "satisfies" => Type::Satisfies,
            "require" => Type::Require,
            "extends" => Type::Extends,
            "implements" => Type::Implements,
            "global" => Type::Global,
            "interface" => Type::Interface,
            "enum" => Type::Enum,
            "-?:" => Type::MinusQMarkColon,
            "+?:" => Type::PlusQMarkColon,
            "?:" => Type::QMarkColon,
            "asserts" => Type::Asserts,
            "infer" => Type::Infer,
            "is" => Type::Is,
            "keyof" => Type::Keyof,
            "unique symbol" => Type::TS0,
            "unknown" => Type::Unknown,
            "never" => Type::Never,
            "{|" => Type::LBracePipe,
            "|}" => Type::PipeRBrace,
            "_automatic_semicolon" => Type::_AutomaticSemicolon,
            "html_comment" => Type::HtmlComment,
            "jsx_text" => Type::JsxText,
            "_function_signature_automatic_semicolon" => Type::_FunctionSignatureAutomaticSemicolon,
            "__error_recovery" => Type::__ErrorRecovery,
            "program" => Type::Program,
            "export_statement" => Type::ExportStatement,
            "namespace_export" => Type::NamespaceExport,
            "export_clause" => Type::ExportClause,
            "export_specifier" => Type::ExportSpecifier,
            "_module_export_name" => Type::_ModuleExportName,
            "declaration" => Type::Declaration,
            "import_statement" => Type::ImportStatement,
            "import_clause" => Type::ImportClause,
            "_from_clause" => Type::_FromClause,
            "namespace_import" => Type::NamespaceImport,
            "named_imports" => Type::NamedImports,
            "import_specifier" => Type::ImportSpecifier,
            "import_attribute" => Type::ImportAttribute,
            "statement" => Type::Statement,
            "expression_statement" => Type::ExpressionStatement,
            "variable_declaration" => Type::VariableDeclaration,
            "lexical_declaration" => Type::LexicalDeclaration,
            "variable_declarator" => Type::VariableDeclarator,
            "statement_block" => Type::StatementBlock,
            "else_clause" => Type::ElseClause,
            "if_statement" => Type::IfStatement,
            "switch_statement" => Type::SwitchStatement,
            "for_statement" => Type::ForStatement,
            "for_in_statement" => Type::ForInStatement,
            "_for_header" => Type::_ForHeader,
            "while_statement" => Type::WhileStatement,
            "do_statement" => Type::DoStatement,
            "try_statement" => Type::TryStatement,
            "with_statement" => Type::WithStatement,
            "break_statement" => Type::BreakStatement,
            "continue_statement" => Type::ContinueStatement,
            "debugger_statement" => Type::DebuggerStatement,
            "return_statement" => Type::ReturnStatement,
            "throw_statement" => Type::ThrowStatement,
            "empty_statement" => Type::EmptyStatement,
            "labeled_statement" => Type::LabeledStatement,
            "switch_body" => Type::SwitchBody,
            "switch_case" => Type::SwitchCase,
            "switch_default" => Type::SwitchDefault,
            "catch_clause" => Type::CatchClause,
            "finally_clause" => Type::FinallyClause,
            "parenthesized_expression" => Type::ParenthesizedExpression,
            "expression" => Type::Expression,
            "primary_expression" => Type::PrimaryExpression,
            "yield_expression" => Type::YieldExpression,
            "object_pattern" => Type::ObjectPattern,
            "assignment_pattern" => Type::AssignmentPattern,
            "object_assignment_pattern" => Type::ObjectAssignmentPattern,
            "array" => Type::Array,
            "array_pattern" => Type::ArrayPattern,
            "nested_identifier" => Type::NestedIdentifier,
            "class_declaration" => Type::ClassDeclaration,
            "class_heritage" => Type::ClassHeritage,
            "function_expression" => Type::FunctionExpression,
            "function_declaration" => Type::FunctionDeclaration,
            "generator_function" => Type::GeneratorFunction,
            "generator_function_declaration" => Type::GeneratorFunctionDeclaration,
            "arrow_function" => Type::ArrowFunction,
            "_call_signature" => Type::_CallSignature,
            "_formal_parameter" => Type::_FormalParameter,
            "optional_chain" => Type::OptionalChain,
            "call_expression" => Type::CallExpression,
            "new_expression" => Type::NewExpression,
            "await_expression" => Type::AwaitExpression,
            "member_expression" => Type::MemberExpression,
            "subscript_expression" => Type::SubscriptExpression,
            "assignment_expression" => Type::AssignmentExpression,
            "_augmented_assignment_lhs" => Type::_AugmentedAssignmentLhs,
            "augmented_assignment_expression" => Type::AugmentedAssignmentExpression,
            "_initializer" => Type::_Initializer,
            "_destructuring_pattern" => Type::_DestructuringPattern,
            "spread_element" => Type::SpreadElement,
            "ternary_expression" => Type::TernaryExpression,
            "binary_expression" => Type::BinaryExpression,
            "unary_expression" => Type::UnaryExpression,
            "update_expression" => Type::UpdateExpression,
            "sequence_expression" => Type::SequenceExpression,
            "template_string" => Type::TemplateString,
            "template_substitution" => Type::TemplateSubstitution,
            "regex" => Type::Regex,
            "meta_property" => Type::MetaProperty,
            "arguments" => Type::Arguments,
            "decorator" => Type::Decorator,
            "class_body" => Type::ClassBody,
            "formal_parameters" => Type::FormalParameters,
            "class_static_block" => Type::ClassStaticBlock,
            "pattern" => Type::Pattern,
            "rest_pattern" => Type::RestPattern,
            "method_definition" => Type::MethodDefinition,
            "pair" => Type::Pair,
            "pair_pattern" => Type::PairPattern,
            "_property_name" => Type::_PropertyName,
            "computed_property_name" => Type::ComputedPropertyName,
            "public_field_definition" => Type::PublicFieldDefinition,
            "_import_identifier" => Type::_ImportIdentifier,
            "non_null_expression" => Type::NonNullExpression,
            "method_signature" => Type::MethodSignature,
            "abstract_method_signature" => Type::AbstractMethodSignature,
            "function_signature" => Type::FunctionSignature,
            "type_assertion" => Type::TypeAssertion,
            "as_expression" => Type::AsExpression,
            "satisfies_expression" => Type::SatisfiesExpression,
            "instantiation_expression" => Type::InstantiationExpression,
            "import_require_clause" => Type::ImportRequireClause,
            "extends_clause" => Type::ExtendsClause,
            "_extends_clause_single" => Type::_ExtendsClauseSingle,
            "implements_clause" => Type::ImplementsClause,
            "ambient_declaration" => Type::AmbientDeclaration,
            "abstract_class_declaration" => Type::AbstractClassDeclaration,
            "internal_module" => Type::InternalModule,
            "_module" => Type::_Module,
            "import_alias" => Type::ImportAlias,
            "nested_type_identifier" => Type::NestedTypeIdentifier,
            "interface_declaration" => Type::InterfaceDeclaration,
            "extends_type_clause" => Type::ExtendsTypeClause,
            "enum_declaration" => Type::EnumDeclaration,
            "enum_body" => Type::EnumBody,
            "enum_assignment" => Type::EnumAssignment,
            "type_alias_declaration" => Type::TypeAliasDeclaration,
            "accessibility_modifier" => Type::AccessibilityModifier,
            "override_modifier" => Type::OverrideModifier,
            "required_parameter" => Type::RequiredParameter,
            "optional_parameter" => Type::OptionalParameter,
            "_parameter_name" => Type::_ParameterName,
            "omitting_type_annotation" => Type::OmittingTypeAnnotation,
            "adding_type_annotation" => Type::AddingTypeAnnotation,
            "opting_type_annotation" => Type::OptingTypeAnnotation,
            "type_annotation" => Type::TypeAnnotation,
            "asserts_annotation" => Type::AssertsAnnotation,
            "optional_type" => Type::OptionalType,
            "rest_type" => Type::RestType,
            "_tuple_type_member" => Type::_TupleTypeMember,
            "constructor_type" => Type::ConstructorType,
            "primary_type" => Type::PrimaryType,
            "template_type" => Type::TemplateType,
            "template_literal_type" => Type::TemplateLiteralType,
            "infer_type" => Type::InferType,
            "conditional_type" => Type::ConditionalType,
            "generic_type" => Type::GenericType,
            "type_predicate" => Type::TypePredicate,
            "type_predicate_annotation" => Type::TypePredicateAnnotation,
            "type_query" => Type::TypeQuery,
            "index_type_query" => Type::IndexTypeQuery,
            "lookup_type" => Type::LookupType,
            "mapped_type_clause" => Type::MappedTypeClause,
            "literal_type" => Type::LiteralType,
            "existential_type" => Type::ExistentialType,
            "flow_maybe_type" => Type::FlowMaybeType,
            "parenthesized_type" => Type::ParenthesizedType,
            "predefined_type" => Type::PredefinedType,
            "type_arguments" => Type::TypeArguments,
            "object_type" => Type::ObjectType,
            "call_signature" => Type::CallSignature,
            "property_signature" => Type::PropertySignature,
            "type_parameters" => Type::TypeParameters,
            "type_parameter" => Type::TypeParameter,
            "default_type" => Type::DefaultType,
            "constraint" => Type::Constraint,
            "construct_signature" => Type::ConstructSignature,
            "index_signature" => Type::IndexSignature,
            "array_type" => Type::ArrayType,
            "tuple_type" => Type::TupleType,
            "readonly_type" => Type::ReadonlyType,
            "union_type" => Type::UnionType,
            "intersection_type" => Type::IntersectionType,
            "function_type" => Type::FunctionType,
            "program_repeat1" => Type::ProgramRepeat1,
            "export_statement_repeat1" => Type::ExportStatementRepeat1,
            "export_clause_repeat1" => Type::ExportClauseRepeat1,
            "named_imports_repeat1" => Type::NamedImportsRepeat1,
            "variable_declaration_repeat1" => Type::VariableDeclarationRepeat1,
            "switch_body_repeat1" => Type::SwitchBodyRepeat1,
            "object_repeat1" => Type::ObjectRepeat1,
            "object_pattern_repeat1" => Type::ObjectPatternRepeat1,
            "array_repeat1" => Type::ArrayRepeat1,
            "array_pattern_repeat1" => Type::ArrayPatternRepeat1,
            "sequence_expression_repeat1" => Type::SequenceExpressionRepeat1,
            "string_repeat1" => Type::StringRepeat1,
            "string_repeat2" => Type::StringRepeat2,
            "template_string_repeat1" => Type::TemplateStringRepeat1,
            "class_body_repeat1" => Type::ClassBodyRepeat1,
            "formal_parameters_repeat1" => Type::FormalParametersRepeat1,
            "extends_clause_repeat1" => Type::ExtendsClauseRepeat1,
            "implements_clause_repeat1" => Type::ImplementsClauseRepeat1,
            "extends_type_clause_repeat1" => Type::ExtendsTypeClauseRepeat1,
            "enum_body_repeat1" => Type::EnumBodyRepeat1,
            "template_literal_type_repeat1" => Type::TemplateLiteralTypeRepeat1,
            "object_type_repeat1" => Type::ObjectTypeRepeat1,
            "type_parameters_repeat1" => Type::TypeParametersRepeat1,
            "tuple_type_repeat1" => Type::TupleTypeRepeat1,
            "interface_body" => Type::InterfaceBody,
            "property_identifier" => Type::PropertyIdentifier,
            "shorthand_property_identifier" => Type::ShorthandPropertyIdentifier,
            "shorthand_property_identifier_pattern" => Type::ShorthandPropertyIdentifierPattern,
            "statement_identifier" => Type::StatementIdentifier,
            "this_type" => Type::ThisType,
            "type_identifier" => Type::TypeIdentifier,
            "Directory" => Type::Directory,
            "Spaces" => Type::Spaces,
            "_ERROR" => Type::_ERROR,
            "ERROR" => Type::ERROR,
            _ => return None,
        })
    }
    pub fn to_str(&self) -> &'static str {
        match self {
            Type::End => "end",
            Type::Identifier => "identifier",
            Type::HashBangLine => "hash_bang_line",
            Type::Export => "export",
            Type::Star => "*",
            Type::Default => "default",
            Type::Type => "type",
            Type::Eq => "=",
            Type::As => "as",
            Type::Namespace => "namespace",
            Type::LBrace => "{",
            Type::Comma => ",",
            Type::RBrace => "}",
            Type::Typeof => "typeof",
            Type::Import => "import",
            Type::From => "from",
            Type::With => "with",
            Type::Assert => "assert",
            Type::Var => "var",
            Type::Let => "let",
            Type::Const => "const",
            Type::Bang => "!",
            Type::Else => "else",
            Type::If => "if",
            Type::Switch => "switch",
            Type::For => "for",
            Type::LParen => "(",
            Type::SemiColon => ";",
            Type::RParen => ")",
            Type::Await => "await",
            Type::In => "in",
            Type::Of => "of",
            Type::While => "while",
            Type::Do => "do",
            Type::Try => "try",
            Type::Break => "break",
            Type::Continue => "continue",
            Type::Debugger => "debugger",
            Type::Return => "return",
            Type::Throw => "throw",
            Type::Colon => ":",
            Type::Case => "case",
            Type::Catch => "catch",
            Type::Finally => "finally",
            Type::Yield => "yield",
            Type::LBracket => "[",
            Type::RBracket => "]",
            Type::Dot => ".",
            Type::Class => "class",
            Type::Async => "async",
            Type::Function => "function",
            Type::BigArrow => "=>",
            Type::QMarkDot => "?.",
            Type::New => "new",
            Type::Using => "using",
            Type::PlusEq => "+=",
            Type::DashEq => "-=",
            Type::StarEq => "*=",
            Type::SlashEq => "/=",
            Type::PercentEq => "%=",
            Type::CaretEq => "^=",
            Type::AmpEq => "&=",
            Type::PipeEq => "|=",
            Type::GtGtEq => ">>=",
            Type::GtGtGtEq => ">>>=",
            Type::LtLtEq => "<<=",
            Type::StarStarEq => "**=",
            Type::AmpAmpEq => "&&=",
            Type::PipePipeEq => "||=",
            Type::QMarkQMarkEq => "??=",
            Type::DotDotDot => "...",
            Type::AmpAmp => "&&",
            Type::PipePipe => "||",
            Type::GtGt => ">>",
            Type::GtGtGt => ">>>",
            Type::LtLt => "<<",
            Type::Amp => "&",
            Type::Caret => "^",
            Type::Pipe => "|",
            Type::Plus => "+",
            Type::Dash => "-",
            Type::Slash => "/",
            Type::Percent => "%",
            Type::StarStar => "**",
            Type::LT => "<",
            Type::LTEq => "<=",
            Type::EqEq => "==",
            Type::EqEqEq => "===",
            Type::BangEq => "!=",
            Type::BangEqEq => "!==",
            Type::GTEq => ">=",
            Type::GT => ">",
            Type::QMarkQMark => "??",
            Type::Instanceof => "instanceof",
            Type::Tilde => "~",
            Type::Void => "void",
            Type::Delete => "delete",
            Type::PlusPlus => "++",
            Type::DashDash => "--",
            Type::DQuote => "\"",
            Type::SQuote => "'",
            Type::StringFragment => "string_fragment",
            Type::EscapeSequence => "escape_sequence",
            Type::Comment => "comment",
            Type::BQuote => "`",
            Type::DollarLBrace => "${",
            Type::RegexPattern => "regex_pattern",
            Type::RegexFlags => "regex_flags",
            Type::Number => "number",
            Type::PrivatePropertyIdentifier => "private_property_identifier",
            Type::Target => "target",
            Type::Meta => "meta",
            Type::This => "this",
            Type::Super => "super",
            Type::True => "true",
            Type::False => "false",
            Type::Null => "null",
            Type::Undefined => "undefined",
            Type::At => "@",
            Type::Static => "static",
            Type::Readonly => "readonly",
            Type::Get => "get",
            Type::Set => "set",
            Type::QMark => "?",
            Type::Declare => "declare",
            Type::Public => "public",
            Type::Private => "private",
            Type::Protected => "protected",
            Type::Override => "override",
            Type::Module => "module",
            Type::Any => "any",
            Type::Boolean => "boolean",
            Type::String => "string",
            Type::Symbol => "symbol",
            Type::Object => "object",
            Type::Abstract => "abstract",
            Type::Accessor => "accessor",
            Type::Satisfies => "satisfies",
            Type::Require => "require",
            Type::Extends => "extends",
            Type::Implements => "implements",
            Type::Global => "global",
            Type::Interface => "interface",
            Type::Enum => "enum",
            Type::MinusQMarkColon => "-?:",
            Type::PlusQMarkColon => "+?:",
            Type::QMarkColon => "?:",
            Type::Asserts => "asserts",
            Type::Infer => "infer",
            Type::Is => "is",
            Type::Keyof => "keyof",
            Type::TS0 => "unique symbol",
            Type::Unknown => "unknown",
            Type::Never => "never",
            Type::LBracePipe => "{|",
            Type::PipeRBrace => "|}",
            Type::_AutomaticSemicolon => "_automatic_semicolon",
            Type::HtmlComment => "html_comment",
            Type::JsxText => "jsx_text",
            Type::_FunctionSignatureAutomaticSemicolon => "_function_signature_automatic_semicolon",
            Type::__ErrorRecovery => "__error_recovery",
            Type::Program => "program",
            Type::ExportStatement => "export_statement",
            Type::NamespaceExport => "namespace_export",
            Type::ExportClause => "export_clause",
            Type::ExportSpecifier => "export_specifier",
            Type::_ModuleExportName => "_module_export_name",
            Type::Declaration => "declaration",
            Type::ImportStatement => "import_statement",
            Type::ImportClause => "import_clause",
            Type::_FromClause => "_from_clause",
            Type::NamespaceImport => "namespace_import",
            Type::NamedImports => "named_imports",
            Type::ImportSpecifier => "import_specifier",
            Type::ImportAttribute => "import_attribute",
            Type::Statement => "statement",
            Type::ExpressionStatement => "expression_statement",
            Type::VariableDeclaration => "variable_declaration",
            Type::LexicalDeclaration => "lexical_declaration",
            Type::VariableDeclarator => "variable_declarator",
            Type::StatementBlock => "statement_block",
            Type::ElseClause => "else_clause",
            Type::IfStatement => "if_statement",
            Type::SwitchStatement => "switch_statement",
            Type::ForStatement => "for_statement",
            Type::ForInStatement => "for_in_statement",
            Type::_ForHeader => "_for_header",
            Type::WhileStatement => "while_statement",
            Type::DoStatement => "do_statement",
            Type::TryStatement => "try_statement",
            Type::WithStatement => "with_statement",
            Type::BreakStatement => "break_statement",
            Type::ContinueStatement => "continue_statement",
            Type::DebuggerStatement => "debugger_statement",
            Type::ReturnStatement => "return_statement",
            Type::ThrowStatement => "throw_statement",
            Type::EmptyStatement => "empty_statement",
            Type::LabeledStatement => "labeled_statement",
            Type::SwitchBody => "switch_body",
            Type::SwitchCase => "switch_case",
            Type::SwitchDefault => "switch_default",
            Type::CatchClause => "catch_clause",
            Type::FinallyClause => "finally_clause",
            Type::ParenthesizedExpression => "parenthesized_expression",
            Type::Expression => "expression",
            Type::PrimaryExpression => "primary_expression",
            Type::YieldExpression => "yield_expression",
            Type::ObjectPattern => "object_pattern",
            Type::AssignmentPattern => "assignment_pattern",
            Type::ObjectAssignmentPattern => "object_assignment_pattern",
            Type::Array => "array",
            Type::ArrayPattern => "array_pattern",
            Type::NestedIdentifier => "nested_identifier",
            Type::ClassDeclaration => "class_declaration",
            Type::ClassHeritage => "class_heritage",
            Type::FunctionExpression => "function_expression",
            Type::FunctionDeclaration => "function_declaration",
            Type::GeneratorFunction => "generator_function",
            Type::GeneratorFunctionDeclaration => "generator_function_declaration",
            Type::ArrowFunction => "arrow_function",
            Type::_CallSignature => "_call_signature",
            Type::_FormalParameter => "_formal_parameter",
            Type::OptionalChain => "optional_chain",
            Type::CallExpression => "call_expression",
            Type::NewExpression => "new_expression",
            Type::AwaitExpression => "await_expression",
            Type::MemberExpression => "member_expression",
            Type::SubscriptExpression => "subscript_expression",
            Type::AssignmentExpression => "assignment_expression",
            Type::_AugmentedAssignmentLhs => "_augmented_assignment_lhs",
            Type::AugmentedAssignmentExpression => "augmented_assignment_expression",
            Type::_Initializer => "_initializer",
            Type::_DestructuringPattern => "_destructuring_pattern",
            Type::SpreadElement => "spread_element",
            Type::TernaryExpression => "ternary_expression",
            Type::BinaryExpression => "binary_expression",
            Type::UnaryExpression => "unary_expression",
            Type::UpdateExpression => "update_expression",
            Type::SequenceExpression => "sequence_expression",
            Type::TemplateString => "template_string",
            Type::TemplateSubstitution => "template_substitution",
            Type::Regex => "regex",
            Type::MetaProperty => "meta_property",
            Type::Arguments => "arguments",
            Type::Decorator => "decorator",
            Type::ClassBody => "class_body",
            Type::FormalParameters => "formal_parameters",
            Type::ClassStaticBlock => "class_static_block",
            Type::Pattern => "pattern",
            Type::RestPattern => "rest_pattern",
            Type::MethodDefinition => "method_definition",
            Type::Pair => "pair",
            Type::PairPattern => "pair_pattern",
            Type::_PropertyName => "_property_name",
            Type::ComputedPropertyName => "computed_property_name",
            Type::PublicFieldDefinition => "public_field_definition",
            Type::_ImportIdentifier => "_import_identifier",
            Type::NonNullExpression => "non_null_expression",
            Type::MethodSignature => "method_signature",
            Type::AbstractMethodSignature => "abstract_method_signature",
            Type::FunctionSignature => "function_signature",
            Type::TypeAssertion => "type_assertion",
            Type::AsExpression => "as_expression",
            Type::SatisfiesExpression => "satisfies_expression",
            Type::InstantiationExpression => "instantiation_expression",
            Type::ImportRequireClause => "import_require_clause",
            Type::ExtendsClause => "extends_clause",
            Type::_ExtendsClauseSingle => "_extends_clause_single",
            Type::ImplementsClause => "implements_clause",
            Type::AmbientDeclaration => "ambient_declaration",
            Type::AbstractClassDeclaration => "abstract_class_declaration",
            Type::InternalModule => "internal_module",
            Type::_Module => "_module",
            Type::ImportAlias => "import_alias",
            Type::NestedTypeIdentifier => "nested_type_identifier",
            Type::InterfaceDeclaration => "interface_declaration",
            Type::ExtendsTypeClause => "extends_type_clause",
            Type::EnumDeclaration => "enum_declaration",
            Type::EnumBody => "enum_body",
            Type::EnumAssignment => "enum_assignment",
            Type::TypeAliasDeclaration => "type_alias_declaration",
            Type::AccessibilityModifier => "accessibility_modifier",
            Type::OverrideModifier => "override_modifier",
            Type::RequiredParameter => "required_parameter",
            Type::OptionalParameter => "optional_parameter",
            Type::_ParameterName => "_parameter_name",
            Type::OmittingTypeAnnotation => "omitting_type_annotation",
            Type::AddingTypeAnnotation => "adding_type_annotation",
            Type::OptingTypeAnnotation => "opting_type_annotation",
            Type::TypeAnnotation => "type_annotation",
            Type::AssertsAnnotation => "asserts_annotation",
            Type::OptionalType => "optional_type",
            Type::RestType => "rest_type",
            Type::_TupleTypeMember => "_tuple_type_member",
            Type::ConstructorType => "constructor_type",
            Type::PrimaryType => "primary_type",
            Type::TemplateType => "template_type",
            Type::TemplateLiteralType => "template_literal_type",
            Type::InferType => "infer_type",
            Type::ConditionalType => "conditional_type",
            Type::GenericType => "generic_type",
            Type::TypePredicate => "type_predicate",
            Type::TypePredicateAnnotation => "type_predicate_annotation",
            Type::TypeQuery => "type_query",
            Type::IndexTypeQuery => "index_type_query",
            Type::LookupType => "lookup_type",
            Type::MappedTypeClause => "mapped_type_clause",
            Type::LiteralType => "literal_type",
            Type::ExistentialType => "existential_type",
            Type::FlowMaybeType => "flow_maybe_type",
            Type::ParenthesizedType => "parenthesized_type",
            Type::PredefinedType => "predefined_type",
            Type::TypeArguments => "type_arguments",
            Type::ObjectType => "object_type",
            Type::CallSignature => "call_signature",
            Type::PropertySignature => "property_signature",
            Type::TypeParameters => "type_parameters",
            Type::TypeParameter => "type_parameter",
            Type::DefaultType => "default_type",
            Type::Constraint => "constraint",
            Type::ConstructSignature => "construct_signature",
            Type::IndexSignature => "index_signature",
            Type::ArrayType => "array_type",
            Type::TupleType => "tuple_type",
            Type::ReadonlyType => "readonly_type",
            Type::UnionType => "union_type",
            Type::IntersectionType => "intersection_type",
            Type::FunctionType => "function_type",
            Type::ProgramRepeat1 => "program_repeat1",
            Type::ExportStatementRepeat1 => "export_statement_repeat1",
            Type::ExportClauseRepeat1 => "export_clause_repeat1",
            Type::NamedImportsRepeat1 => "named_imports_repeat1",
            Type::VariableDeclarationRepeat1 => "variable_declaration_repeat1",
            Type::SwitchBodyRepeat1 => "switch_body_repeat1",
            Type::ObjectRepeat1 => "object_repeat1",
            Type::ObjectPatternRepeat1 => "object_pattern_repeat1",
            Type::ArrayRepeat1 => "array_repeat1",
            Type::ArrayPatternRepeat1 => "array_pattern_repeat1",
            Type::SequenceExpressionRepeat1 => "sequence_expression_repeat1",
            Type::StringRepeat1 => "string_repeat1",
            Type::StringRepeat2 => "string_repeat2",
            Type::TemplateStringRepeat1 => "template_string_repeat1",
            Type::ClassBodyRepeat1 => "class_body_repeat1",
            Type::FormalParametersRepeat1 => "formal_parameters_repeat1",
            Type::ExtendsClauseRepeat1 => "extends_clause_repeat1",
            Type::ImplementsClauseRepeat1 => "implements_clause_repeat1",
            Type::ExtendsTypeClauseRepeat1 => "extends_type_clause_repeat1",
            Type::EnumBodyRepeat1 => "enum_body_repeat1",
            Type::TemplateLiteralTypeRepeat1 => "template_literal_type_repeat1",
            Type::ObjectTypeRepeat1 => "object_type_repeat1",
            Type::TypeParametersRepeat1 => "type_parameters_repeat1",
            Type::TupleTypeRepeat1 => "tuple_type_repeat1",
            Type::InterfaceBody => "interface_body",
            Type::PropertyIdentifier => "property_identifier",
            Type::ShorthandPropertyIdentifier => "shorthand_property_identifier",
            Type::ShorthandPropertyIdentifierPattern => "shorthand_property_identifier_pattern",
            Type::StatementIdentifier => "statement_identifier",
            Type::ThisType => "this_type",
            Type::TypeIdentifier => "type_identifier",
            Type::Spaces => "Spaces",
            Type::Directory => "Directory",
            Type::_ERROR => "_ERROR",
            Type::ERROR => "ERROR",
        }
    }
    pub fn is_hidden(&self) -> bool {
        match self {
            Type::End => true,
            Type::_AutomaticSemicolon => true,
            Type::_FunctionSignatureAutomaticSemicolon => true,
            Type::__ErrorRecovery => true,
            Type::_ModuleExportName => true,
            Type::Declaration => true,
            Type::_FromClause => true,
            Type::Statement => true,
            Type::_ForHeader => true,
            Type::Expression => true,
            Type::PrimaryExpression => true,
            Type::_CallSignature => true,
            Type::_FormalParameter => true,
            Type::_AugmentedAssignmentLhs => true,
            Type::_Initializer => true,
            Type::_DestructuringPattern => true,
            Type::Pattern => true,
            Type::_PropertyName => true,
            Type::_ImportIdentifier => true,
            Type::_ExtendsClauseSingle => true,
            Type::_Module => true,
            Type::_ParameterName => true,
            Type::_TupleTypeMember => true,
            Type::PrimaryType => true,
            Type::ProgramRepeat1 => true,
            Type::ExportStatementRepeat1 => true,
            Type::ExportClauseRepeat1 => true,
            Type::NamedImportsRepeat1 => true,
            Type::VariableDeclarationRepeat1 => true,
            Type::SwitchBodyRepeat1 => true,
            Type::ObjectRepeat1 => true,
            Type::ObjectPatternRepeat1 => true,
            Type::ArrayRepeat1 => true,
            Type::ArrayPatternRepeat1 => true,
            Type::SequenceExpressionRepeat1 => true,
            Type::StringRepeat1 => true,
            Type::StringRepeat2 => true,
            Type::TemplateStringRepeat1 => true,
            Type::ClassBodyRepeat1 => true,
            Type::FormalParametersRepeat1 => true,
            Type::ExtendsClauseRepeat1 => true,
            Type::ImplementsClauseRepeat1 => true,
            Type::ExtendsTypeClauseRepeat1 => true,
            Type::EnumBodyRepeat1 => true,
            Type::TemplateLiteralTypeRepeat1 => true,
            Type::ObjectTypeRepeat1 => true,
            Type::TypeParametersRepeat1 => true,
            Type::TupleTypeRepeat1 => true,
            _ => false,
        }
    }
    pub fn is_supertype(&self) -> bool {
        match self {
            Type::Declaration => true,
            Type::Statement => true,
            Type::Expression => true,
            Type::PrimaryExpression => true,
            Type::Pattern => true,
            Type::PrimaryType => true,
            _ => false,
        }
    }
    pub fn is_named(&self) -> bool {
        match self {
            Type::Identifier => true,
            Type::HashBangLine => true,
            Type::StringFragment => true,
            Type::EscapeSequence => true,
            Type::Comment => true,
            Type::RegexPattern => true,
            Type::RegexFlags => true,
            Type::PrivatePropertyIdentifier => true,
            Type::This => true,
            Type::Super => true,
            Type::True => true,
            Type::False => true,
            Type::Null => true,
            Type::Undefined => true,
            Type::HtmlComment => true,
            Type::JsxText => true,
            Type::Program => true,
            Type::ExportStatement => true,
            Type::NamespaceExport => true,
            Type::ExportClause => true,
            Type::ExportSpecifier => true,
            Type::Declaration => true,
            Type::ImportStatement => true,
            Type::ImportClause => true,
            Type::NamespaceImport => true,
            Type::NamedImports => true,
            Type::ImportSpecifier => true,
            Type::ImportAttribute => true,
            Type::Statement => true,
            Type::ExpressionStatement => true,
            Type::VariableDeclaration => true,
            Type::LexicalDeclaration => true,
            Type::VariableDeclarator => true,
            Type::StatementBlock => true,
            Type::ElseClause => true,
            Type::IfStatement => true,
            Type::SwitchStatement => true,
            Type::ForStatement => true,
            Type::ForInStatement => true,
            Type::WhileStatement => true,
            Type::DoStatement => true,
            Type::TryStatement => true,
            Type::WithStatement => true,
            Type::BreakStatement => true,
            Type::ContinueStatement => true,
            Type::DebuggerStatement => true,
            Type::ReturnStatement => true,
            Type::ThrowStatement => true,
            Type::EmptyStatement => true,
            Type::LabeledStatement => true,
            Type::SwitchBody => true,
            Type::SwitchCase => true,
            Type::SwitchDefault => true,
            Type::CatchClause => true,
            Type::FinallyClause => true,
            Type::ParenthesizedExpression => true,
            Type::Expression => true,
            Type::PrimaryExpression => true,
            Type::YieldExpression => true,
            Type::ObjectPattern => true,
            Type::AssignmentPattern => true,
            Type::ObjectAssignmentPattern => true,
            Type::Array => true,
            Type::ArrayPattern => true,
            Type::NestedIdentifier => true,
            Type::ClassDeclaration => true,
            Type::ClassHeritage => true,
            Type::FunctionExpression => true,
            Type::FunctionDeclaration => true,
            Type::GeneratorFunction => true,
            Type::GeneratorFunctionDeclaration => true,
            Type::ArrowFunction => true,
            Type::OptionalChain => true,
            Type::CallExpression => true,
            Type::NewExpression => true,
            Type::AwaitExpression => true,
            Type::MemberExpression => true,
            Type::SubscriptExpression => true,
            Type::AssignmentExpression => true,
            Type::AugmentedAssignmentExpression => true,
            Type::SpreadElement => true,
            Type::TernaryExpression => true,
            Type::BinaryExpression => true,
            Type::UnaryExpression => true,
            Type::UpdateExpression => true,
            Type::SequenceExpression => true,
            Type::TemplateString => true,
            Type::TemplateSubstitution => true,
            Type::Regex => true,
            Type::MetaProperty => true,
            Type::Arguments => true,
            Type::Decorator => true,
            Type::ClassBody => true,
            Type::FormalParameters => true,
            Type::ClassStaticBlock => true,
            Type::Pattern => true,
            Type::RestPattern => true,
            Type::MethodDefinition => true,
            Type::Pair => true,
            Type::PairPattern => true,
            Type::ComputedPropertyName => true,
            Type::PublicFieldDefinition => true,
            Type::NonNullExpression => true,
            Type::MethodSignature => true,
            Type::AbstractMethodSignature => true,
            Type::FunctionSignature => true,
            Type::TypeAssertion => true,
            Type::AsExpression => true,
            Type::SatisfiesExpression => true,
            Type::InstantiationExpression => true,
            Type::ImportRequireClause => true,
            Type::ExtendsClause => true,
            Type::ImplementsClause => true,
            Type::AmbientDeclaration => true,
            Type::AbstractClassDeclaration => true,
            Type::InternalModule => true,
            Type::ImportAlias => true,
            Type::NestedTypeIdentifier => true,
            Type::InterfaceDeclaration => true,
            Type::ExtendsTypeClause => true,
            Type::EnumDeclaration => true,
            Type::EnumBody => true,
            Type::EnumAssignment => true,
            Type::TypeAliasDeclaration => true,
            Type::AccessibilityModifier => true,
            Type::OverrideModifier => true,
            Type::RequiredParameter => true,
            Type::OptionalParameter => true,
            Type::OmittingTypeAnnotation => true,
            Type::AddingTypeAnnotation => true,
            Type::OptingTypeAnnotation => true,
            Type::TypeAnnotation => true,
            Type::AssertsAnnotation => true,
            Type::OptionalType => true,
            Type::RestType => true,
            Type::ConstructorType => true,
            Type::PrimaryType => true,
            Type::TemplateType => true,
            Type::TemplateLiteralType => true,
            Type::InferType => true,
            Type::ConditionalType => true,
            Type::GenericType => true,
            Type::TypePredicate => true,
            Type::TypePredicateAnnotation => true,
            Type::TypeQuery => true,
            Type::IndexTypeQuery => true,
            Type::LookupType => true,
            Type::MappedTypeClause => true,
            Type::LiteralType => true,
            Type::ExistentialType => true,
            Type::FlowMaybeType => true,
            Type::ParenthesizedType => true,
            Type::PredefinedType => true,
            Type::TypeArguments => true,
            Type::ObjectType => true,
            Type::CallSignature => true,
            Type::PropertySignature => true,
            Type::TypeParameters => true,
            Type::TypeParameter => true,
            Type::DefaultType => true,
            Type::Constraint => true,
            Type::ConstructSignature => true,
            Type::IndexSignature => true,
            Type::ArrayType => true,
            Type::TupleType => true,
            Type::ReadonlyType => true,
            Type::UnionType => true,
            Type::IntersectionType => true,
            Type::FunctionType => true,
            Type::InterfaceBody => true,
            Type::PropertyIdentifier => true,
            Type::ShorthandPropertyIdentifier => true,
            Type::ShorthandPropertyIdentifierPattern => true,
            Type::StatementIdentifier => true,
            Type::ThisType => true,
            Type::TypeIdentifier => true,
            _ => false,
        }
    }
    pub fn is_repeat(&self) -> bool {
        todo!()
    }
}

const S_T_L: &'static [Type] = &[
    Type::End,
    Type::Identifier,
    Type::HashBangLine,
    Type::Export,
    Type::Star,
    Type::Default,
    Type::Type,
    Type::Eq,
    Type::As,
    Type::Namespace,
    Type::LBrace,
    Type::Comma,
    Type::RBrace,
    Type::Typeof,
    Type::Import,
    Type::From,
    Type::With,
    Type::Assert,
    Type::Var,
    Type::Let,
    Type::Const,
    Type::Bang,
    Type::Else,
    Type::If,
    Type::Switch,
    Type::For,
    Type::LParen,
    Type::SemiColon,
    Type::RParen,
    Type::Await,
    Type::In,
    Type::Of,
    Type::While,
    Type::Do,
    Type::Try,
    Type::Break,
    Type::Continue,
    Type::Debugger,
    Type::Return,
    Type::Throw,
    Type::Colon,
    Type::Case,
    Type::Catch,
    Type::Finally,
    Type::Yield,
    Type::LBracket,
    Type::RBracket,
    Type::Dot,
    Type::Class,
    Type::Async,
    Type::Function,
    Type::BigArrow,
    Type::QMarkDot,
    Type::New,
    Type::Using,
    Type::PlusEq,
    Type::DashEq,
    Type::StarEq,
    Type::SlashEq,
    Type::PercentEq,
    Type::CaretEq,
    Type::AmpEq,
    Type::PipeEq,
    Type::GtGtEq,
    Type::GtGtGtEq,
    Type::LtLtEq,
    Type::StarStarEq,
    Type::AmpAmpEq,
    Type::PipePipeEq,
    Type::QMarkQMarkEq,
    Type::DotDotDot,
    Type::AmpAmp,
    Type::PipePipe,
    Type::GtGt,
    Type::GtGtGt,
    Type::LtLt,
    Type::Amp,
    Type::Caret,
    Type::Pipe,
    Type::Plus,
    Type::Dash,
    Type::Slash,
    Type::Percent,
    Type::StarStar,
    Type::LT,
    Type::LTEq,
    Type::EqEq,
    Type::EqEqEq,
    Type::BangEq,
    Type::BangEqEq,
    Type::GTEq,
    Type::GT,
    Type::QMarkQMark,
    Type::Instanceof,
    Type::Tilde,
    Type::Void,
    Type::Delete,
    Type::PlusPlus,
    Type::DashDash,
    Type::DQuote,
    Type::SQuote,
    Type::StringFragment,
    Type::EscapeSequence,
    Type::Comment,
    Type::BQuote,
    Type::DollarLBrace,
    Type::RegexPattern,
    Type::RegexFlags,
    Type::Number,
    Type::PrivatePropertyIdentifier,
    Type::Target,
    Type::Meta,
    Type::This,
    Type::Super,
    Type::True,
    Type::False,
    Type::Null,
    Type::Undefined,
    Type::At,
    Type::Static,
    Type::Readonly,
    Type::Get,
    Type::Set,
    Type::QMark,
    Type::Declare,
    Type::Public,
    Type::Private,
    Type::Protected,
    Type::Override,
    Type::Module,
    Type::Any,
    Type::Boolean,
    Type::String,
    Type::Symbol,
    Type::Object,
    Type::Abstract,
    Type::Accessor,
    Type::Satisfies,
    Type::Require,
    Type::Extends,
    Type::Implements,
    Type::Global,
    Type::Interface,
    Type::Enum,
    Type::MinusQMarkColon,
    Type::PlusQMarkColon,
    Type::QMarkColon,
    Type::Asserts,
    Type::Infer,
    Type::Is,
    Type::Keyof,
    Type::TS0,
    Type::Unknown,
    Type::Never,
    Type::LBracePipe,
    Type::PipeRBrace,
    Type::_AutomaticSemicolon,
    Type::HtmlComment,
    Type::JsxText,
    Type::_FunctionSignatureAutomaticSemicolon,
    Type::__ErrorRecovery,
    Type::Program,
    Type::ExportStatement,
    Type::NamespaceExport,
    Type::ExportClause,
    Type::ExportSpecifier,
    Type::_ModuleExportName,
    Type::Declaration,
    Type::ImportStatement,
    Type::ImportClause,
    Type::_FromClause,
    Type::NamespaceImport,
    Type::NamedImports,
    Type::ImportSpecifier,
    Type::ImportAttribute,
    Type::Statement,
    Type::ExpressionStatement,
    Type::VariableDeclaration,
    Type::LexicalDeclaration,
    Type::VariableDeclarator,
    Type::StatementBlock,
    Type::ElseClause,
    Type::IfStatement,
    Type::SwitchStatement,
    Type::ForStatement,
    Type::ForInStatement,
    Type::_ForHeader,
    Type::WhileStatement,
    Type::DoStatement,
    Type::TryStatement,
    Type::WithStatement,
    Type::BreakStatement,
    Type::ContinueStatement,
    Type::DebuggerStatement,
    Type::ReturnStatement,
    Type::ThrowStatement,
    Type::EmptyStatement,
    Type::LabeledStatement,
    Type::SwitchBody,
    Type::SwitchCase,
    Type::SwitchDefault,
    Type::CatchClause,
    Type::FinallyClause,
    Type::ParenthesizedExpression,
    Type::Expression,
    Type::PrimaryExpression,
    Type::YieldExpression,
    Type::ObjectPattern,
    Type::AssignmentPattern,
    Type::ObjectAssignmentPattern,
    Type::Array,
    Type::ArrayPattern,
    Type::NestedIdentifier,
    Type::ClassDeclaration,
    Type::ClassHeritage,
    Type::FunctionExpression,
    Type::FunctionDeclaration,
    Type::GeneratorFunction,
    Type::GeneratorFunctionDeclaration,
    Type::ArrowFunction,
    Type::_CallSignature,
    Type::_FormalParameter,
    Type::OptionalChain,
    Type::CallExpression,
    Type::NewExpression,
    Type::AwaitExpression,
    Type::MemberExpression,
    Type::SubscriptExpression,
    Type::AssignmentExpression,
    Type::_AugmentedAssignmentLhs,
    Type::AugmentedAssignmentExpression,
    Type::_Initializer,
    Type::_DestructuringPattern,
    Type::SpreadElement,
    Type::TernaryExpression,
    Type::BinaryExpression,
    Type::UnaryExpression,
    Type::UpdateExpression,
    Type::SequenceExpression,
    Type::TemplateString,
    Type::TemplateSubstitution,
    Type::Regex,
    Type::MetaProperty,
    Type::Arguments,
    Type::Decorator,
    Type::ClassBody,
    Type::FormalParameters,
    Type::ClassStaticBlock,
    Type::Pattern,
    Type::RestPattern,
    Type::MethodDefinition,
    Type::Pair,
    Type::PairPattern,
    Type::_PropertyName,
    Type::ComputedPropertyName,
    Type::PublicFieldDefinition,
    Type::_ImportIdentifier,
    Type::NonNullExpression,
    Type::MethodSignature,
    Type::AbstractMethodSignature,
    Type::FunctionSignature,
    Type::TypeAssertion,
    Type::AsExpression,
    Type::SatisfiesExpression,
    Type::InstantiationExpression,
    Type::ImportRequireClause,
    Type::ExtendsClause,
    Type::_ExtendsClauseSingle,
    Type::ImplementsClause,
    Type::AmbientDeclaration,
    Type::AbstractClassDeclaration,
    Type::InternalModule,
    Type::_Module,
    Type::ImportAlias,
    Type::NestedTypeIdentifier,
    Type::InterfaceDeclaration,
    Type::ExtendsTypeClause,
    Type::EnumDeclaration,
    Type::EnumBody,
    Type::EnumAssignment,
    Type::TypeAliasDeclaration,
    Type::AccessibilityModifier,
    Type::OverrideModifier,
    Type::RequiredParameter,
    Type::OptionalParameter,
    Type::_ParameterName,
    Type::OmittingTypeAnnotation,
    Type::AddingTypeAnnotation,
    Type::OptingTypeAnnotation,
    Type::TypeAnnotation,
    Type::AssertsAnnotation,
    Type::OptionalType,
    Type::RestType,
    Type::_TupleTypeMember,
    Type::ConstructorType,
    Type::PrimaryType,
    Type::TemplateType,
    Type::TemplateLiteralType,
    Type::InferType,
    Type::ConditionalType,
    Type::GenericType,
    Type::TypePredicate,
    Type::TypePredicateAnnotation,
    Type::TypeQuery,
    Type::IndexTypeQuery,
    Type::LookupType,
    Type::MappedTypeClause,
    Type::LiteralType,
    Type::ExistentialType,
    Type::FlowMaybeType,
    Type::ParenthesizedType,
    Type::PredefinedType,
    Type::TypeArguments,
    Type::ObjectType,
    Type::CallSignature,
    Type::PropertySignature,
    Type::TypeParameters,
    Type::TypeParameter,
    Type::DefaultType,
    Type::Constraint,
    Type::ConstructSignature,
    Type::IndexSignature,
    Type::ArrayType,
    Type::TupleType,
    Type::ReadonlyType,
    Type::UnionType,
    Type::IntersectionType,
    Type::FunctionType,
    Type::ProgramRepeat1,
    Type::ExportStatementRepeat1,
    Type::ExportClauseRepeat1,
    Type::NamedImportsRepeat1,
    Type::VariableDeclarationRepeat1,
    Type::SwitchBodyRepeat1,
    Type::ObjectRepeat1,
    Type::ObjectPatternRepeat1,
    Type::ArrayRepeat1,
    Type::ArrayPatternRepeat1,
    Type::SequenceExpressionRepeat1,
    Type::StringRepeat1,
    Type::StringRepeat2,
    Type::TemplateStringRepeat1,
    Type::ClassBodyRepeat1,
    Type::FormalParametersRepeat1,
    Type::ExtendsClauseRepeat1,
    Type::ImplementsClauseRepeat1,
    Type::ExtendsTypeClauseRepeat1,
    Type::EnumBodyRepeat1,
    Type::TemplateLiteralTypeRepeat1,
    Type::ObjectTypeRepeat1,
    Type::TypeParametersRepeat1,
    Type::TupleTypeRepeat1,
    Type::InterfaceBody,
    Type::PropertyIdentifier,
    Type::ShorthandPropertyIdentifier,
    Type::ShorthandPropertyIdentifierPattern,
    Type::StatementIdentifier,
    Type::ThisType,
    Type::TypeIdentifier,
];
